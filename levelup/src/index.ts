import { app, BrowserWindow, dialog, ipcMain } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import ffmpeg from 'fluent-ffmpeg';
import ffmpegPath from '@ffmpeg-installer/ffmpeg';
import { exec } from 'child_process';
import { NormalizationSettings } from './interfaces';

// Set the ffmpeg path correctly
ffmpeg.setFfmpegPath(ffmpegPath.path);

// Ensure the binary is executable
exec(`chmod +x "${ffmpegPath.path}"`, (error) => {
  if (error) {
    console.error('Error setting execute permissions:', error);
  } else {
    console.log('FFmpeg executable permissions set successfully');
  }
});

// Also verify the file exists
if (fs.existsSync(ffmpegPath.path)) {
  console.log('FFmpeg found at:', ffmpegPath.path);
} else {
  console.error('FFmpeg binary not found at:', ffmpegPath.path);
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let mainWindow: BrowserWindow;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 700,
    width: 900,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development.
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// File selection dialog
ipcMain.handle('select-files', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
    properties: ['openFile', 'multiSelections'],
    filters: [
      { name: 'Audio Files', extensions: ['mp3', 'wav', 'flac', 'aac', 'm4a', 'ogg'] }
    ]
  });
  
  if (canceled) {
    return [];
  }
  
  return filePaths;
});

// Output directory selection dialog
ipcMain.handle('select-output-directory', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
    properties: ['openDirectory']
  });
  
  if (canceled || filePaths.length === 0) {
    return null;
  }
  
  return filePaths[0];
});

// Clean up temporary files in a directory
ipcMain.handle('cleanup-temp-files', async (event, directoryPath: string) => {
  try {
    console.log(`Cleaning up temporary files in: ${directoryPath}`);
    let cleanedCount = 0;
    
    if (!fs.existsSync(directoryPath)) {
      return { success: false, message: 'Directory does not exist' };
    }
    
    const files = fs.readdirSync(directoryPath);
    
    // Pattern to match temp files: *_temp_pass*.mp3, *_temp_pass*.wav, etc.
    const tempPattern = /_temp_pass\d+\.(mp3|wav|flac|aac|m4a|ogg)$/i;
    
    for (const file of files) {
      if (tempPattern.test(file)) {
        const fullPath = path.join(directoryPath, file);
        try {
          fs.unlinkSync(fullPath);
          console.log(`🧹 Cleaned up: ${file}`);
          cleanedCount++;
        } catch (err) {
          console.warn(`Failed to delete ${file}:`, err);
        }
      }
    }
    
    return { 
      success: true, 
      message: `Cleaned up ${cleanedCount} temporary files`,
      count: cleanedCount 
    };
    
  } catch (error) {
    console.error('Error cleaning up temp files:', error);
    return { 
      success: false, 
      message: `Error: ${error.message}` 
    };
  }
});

// Audio processing with parallel support for large batches
ipcMain.handle('process-audio', async (event, filePaths: string[], settings: NormalizationSettings) => {
  try {
    // Verify FFmpeg is working
    await testFfmpegPath();
    
    // Determine output directory
    const outputDir = settings.outputDirectory || path.join(app.getPath('music'), 'LevelUp');
    
    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Determine if we should use parallel processing
    const shouldUseParallel = settings.enableParallelProcessing !== false && filePaths.length > 3;
    const maxConcurrent = settings.maxConcurrentJobs || Math.max(1, os.cpus().length - 1);
    
    console.log(`=== BATCH PROCESSING START ===`);
    console.log(`Files to process: ${filePaths.length}`);
    console.log(`Parallel processing: ${shouldUseParallel ? 'ENABLED' : 'DISABLED'}`);
    console.log(`Max concurrent jobs: ${maxConcurrent}`);
    
    if (shouldUseParallel && filePaths.length > 1) {
      // Use parallel processing for large batches
      await processFilesInParallel(filePaths, outputDir, settings, event, maxConcurrent);
    } else {
      // Use sequential processing for small batches or when disabled
      await processFilesSequentially(filePaths, outputDir, settings, event);
    }
    
    console.log(`=== BATCH PROCESSING COMPLETE ===`);
    
  } catch (error) {
    console.error('FFmpeg validation failed:', error);
    throw new Error(`FFmpeg not available: ${error.message}`);
  }
});

// Sequential processing (original method)
async function processFilesSequentially(
  filePaths: string[],
  outputDir: string,
  settings: NormalizationSettings,
  event: Electron.IpcMainInvokeEvent
): Promise<void> {
  console.log('Using sequential processing...');
  
  for (const filePath of filePaths) {
    try {
      const outputPath = generateOutputPath(filePath, outputDir, settings);
      
      await normalizeAudio(filePath, outputPath, settings.targetLUFS, settings.truePeakLimit, settings, event);
    } catch (error) {
      console.error(`Error processing ${filePath}:`, error);
      // Send error to renderer to update UI
      mainWindow.webContents.send('progress-update', {
        filePath: filePath,
        percent: 0,
        error: `Failed: ${error.message || 'Unknown error'}`
      });
    }
  }
}

// Parallel processing using worker pool
async function processFilesInParallel(
  filePaths: string[],
  outputDir: string,
  settings: NormalizationSettings,
  event: Electron.IpcMainInvokeEvent,
  maxConcurrent: number
): Promise<void> {
  console.log(`Using parallel processing with ${maxConcurrent} workers...`);
  
  // Create work queue
  const workQueue = filePaths.map(filePath => ({
    filePath,
    outputPath: generateOutputPath(filePath, outputDir, settings)
  }));
  
  // Track progress
  let completed = 0;
  let failed = 0;
  const total = workQueue.length;
  
  // Create worker pool using Promise-based concurrency
  const workers: Promise<void>[] = [];
  let queueIndex = 0;
  
  // Create worker function
  const createWorker = async (workerId: number): Promise<void> => {
    console.log(`Worker ${workerId} started`);
    
    while (queueIndex < workQueue.length) {
      // Get next job from queue (thread-safe increment)
      const jobIndex = queueIndex++;
      if (jobIndex >= workQueue.length) break;
      
      const job = workQueue[jobIndex];
      console.log(`Worker ${workerId} processing job ${jobIndex + 1}/${total}: ${path.basename(job.filePath)}`);
      
      try {
        // Process the file
        await normalizeAudio(
          job.filePath, 
          job.outputPath, 
          settings.targetLUFS, 
          settings.truePeakLimit, 
          settings, 
          event
        );
        
        completed++;
        console.log(`Worker ${workerId} completed job ${jobIndex + 1}/${total} (${completed}/${total} total completed)`);
        
        // Send overall progress update
        const overallProgress = Math.round((completed / total) * 100);
        mainWindow.webContents.send('batch-progress-update', {
          completed,
          failed,
          total,
          overallProgress
        });
        
      } catch (error) {
        failed++;
        console.error(`Worker ${workerId} failed job ${jobIndex + 1}/${total}:`, error);
        
        // Send error to renderer
        mainWindow.webContents.send('progress-update', {
          filePath: job.filePath,
          percent: 0,
          error: `Failed: ${error.message || 'Unknown error'}`
        });
      }
    }
    
    console.log(`Worker ${workerId} finished`);
  };
  
  // Start workers
  for (let i = 0; i < maxConcurrent; i++) {
    workers.push(createWorker(i + 1));
  }
  
  // Wait for all workers to complete
  await Promise.all(workers);
  
  console.log(`=== PARALLEL PROCESSING SUMMARY ===`);
  console.log(`Total files: ${total}`);
  console.log(`Completed: ${completed}`);
  console.log(`Failed: ${failed}`);
  console.log(`Success rate: ${((completed / total) * 100).toFixed(1)}%`);
}

// Helper function to determine output path based on format preservation setting
function generateOutputPath(inputFilePath: string, outputDir: string, settings: NormalizationSettings): string {
  const fileName = path.basename(inputFilePath);
  const fileNameWithoutExt = path.parse(fileName).name;
  
  if (settings.preserveOriginalFormat) {
    // Keep original format - extract extension from input file
    const originalExtension = path.extname(inputFilePath).slice(1).toLowerCase();
    console.log(`Format preservation mode: keeping original format (${originalExtension.toUpperCase()})`);
    return path.join(outputDir, `${fileNameWithoutExt}_normalized.${originalExtension}`);
  } else {
    // Use specified output format
    return path.join(outputDir, `${fileNameWithoutExt}_normalized.${settings.outputFormat}`);
  }
}

// Test if FFmpeg is installed and accessible
async function testFfmpegPath(): Promise<void> {
  return new Promise((resolve, reject) => {
    ffmpeg.getAvailableFormats((err, formats) => {
      if (err) {
        console.error('FFmpeg is not accessible:', err);
        reject(err);
      } else {
        console.log('FFmpeg is working correctly');
        resolve();
      }
    });
  });
}

// Iterative multi-pass loudnorm implementation for maximum accuracy
async function performIterativeNormalization(
  inputPath: string,
  outputPath: string,
  targetLUFS: number,
  truePeakLimit: number,
  settings: NormalizationSettings,
  event: Electron.IpcMainInvokeEvent
): Promise<void> {
  return new Promise((resolve, reject) => {
    (async () => {
    console.log(`=== ITERATIVE MULTI-PASS NORMALIZATION ===`);
    console.log(`Input: ${inputPath}`);
    console.log(`Output: ${outputPath}`);
    console.log(`Target: ${targetLUFS} LUFS, ${truePeakLimit} dBTP`);
    console.log(`High-Quality Mode: ${settings.useHighQualityMode ? 'ENABLED (WAV intermediates)' : 'DISABLED (same format intermediates)'}`);
    
    const maxPasses = Math.min(settings.maxPasses || 2, 5); // Cap at 5 passes for safety
    const accuracyThreshold = settings.accuracyThreshold || 0.1; // Default 0.1 LUFS tolerance
    
    console.log(`Max passes: ${maxPasses}, Accuracy threshold: ±${accuracyThreshold} LUFS`);
    
    let currentInputPath = inputPath;
    let tempOutputPath = outputPath;
    let passNumber = 1;
    let lastAccuracy = Number.MAX_VALUE;
    
    // Determine intermediate format based on high-quality mode
    const intermediateFormat = settings.useHighQualityMode ? 'wav' : path.extname(outputPath).slice(1);
    const finalFormat = path.extname(outputPath).slice(1);
    
    if (settings.useHighQualityMode) {
      console.log(`🎵 Using HIGH-QUALITY mode: ${intermediateFormat.toUpperCase()} intermediates → ${finalFormat.toUpperCase()} final`);
    } else {
      console.log(`⚡ Using FAST mode: ${finalFormat.toUpperCase()} intermediates`);
    }
    
    try {
      while (passNumber <= maxPasses) {
        console.log(`\n=== PASS ${passNumber}/${maxPasses} ===`);
        
        // For intermediate passes, use the determined intermediate format
        if (passNumber < maxPasses) {
          const tempDir = path.dirname(outputPath);
          const fileName = path.basename(outputPath, path.extname(outputPath));
          tempOutputPath = path.join(tempDir, `${fileName}_temp_pass${passNumber}.${intermediateFormat}`);
        } else {
          tempOutputPath = outputPath; // Final pass uses the actual output path and format
        }
        
        console.log(`Pass ${passNumber}: ${path.basename(currentInputPath)} → ${path.basename(tempOutputPath)}`);
        
        // Perform two-pass normalization for this iteration
        await performTwoPassNormalization(
          currentInputPath, 
          tempOutputPath, 
          targetLUFS, 
          truePeakLimit, 
          settings, 
          event
        );
        
        // Verify accuracy after this pass
        const accuracy = await getAccuracyMeasurement(tempOutputPath, targetLUFS, truePeakLimit, settings);
        
        console.log(`Pass ${passNumber} accuracy: ${accuracy.lufsError.toFixed(3)} LUFS error`);
        
        // Update progress (spread across all passes)
        const progressPercent = Math.round((passNumber / maxPasses) * 100);
        mainWindow.webContents.send('progress-update', {
          filePath: inputPath,
          percent: progressPercent
        });
        
        // Check if we've achieved target accuracy
        if (accuracy.lufsError <= accuracyThreshold) {
          console.log(`🎯 TARGET ACCURACY ACHIEVED after ${passNumber} passes!`);
          console.log(`Final accuracy: ±${accuracy.lufsError.toFixed(3)} LUFS`);
          
          // Clean up temporary files - DISABLED FOR SAFETY (was deleting wrong files)
          // await cleanupTempFiles(inputPath, outputPath, passNumber, intermediateFormat);
          
          mainWindow.webContents.send('progress-update', {
            filePath: inputPath,
            percent: 100
          });
          resolve();
          return;
        }
        
        // Check if we're still improving
        if (accuracy.lufsError >= lastAccuracy && passNumber > 2) {
          console.log(`⚠️  No improvement after pass ${passNumber}, stopping iteration`);
          break;
        }
        
        lastAccuracy = accuracy.lufsError;
        
        // Prepare for next pass (if not the last one)
        if (passNumber < maxPasses) {
          // Clean up previous temp file if it exists
          if (currentInputPath !== inputPath && fs.existsSync(currentInputPath)) {
            fs.unlinkSync(currentInputPath);
            console.log(`🧹 Cleaned up previous temp file: ${path.basename(currentInputPath)}`);
          }
          currentInputPath = tempOutputPath; // Next pass uses this output as input
        }
        
        passNumber++;
      }
      
      // If we exit the loop without achieving target accuracy
      console.log(`⚠️  Maximum passes (${maxPasses}) reached`);
      console.log(`Final accuracy: ±${lastAccuracy.toFixed(3)} LUFS (target was ±${accuracyThreshold})`);
      
      // Clean up temporary files - DISABLED FOR SAFETY (was deleting wrong files)
      // await cleanupTempFiles(inputPath, outputPath, passNumber - 1, intermediateFormat);
      
      mainWindow.webContents.send('progress-update', {
        filePath: inputPath,
        percent: 100
      });
      resolve();
      
    } catch (error) {
      console.error('Error in iterative normalization:', error);
      // Clean up on error - DISABLED FOR SAFETY (was deleting wrong files)
      // await cleanupTempFiles(inputPath, outputPath, passNumber, intermediateFormat);
      reject(error);
    }
    })().catch(reject);
  });
}

// Helper function to measure accuracy without full verification output
async function getAccuracyMeasurement(filePath: string, targetLUFS: number, targetTP: number, settings?: NormalizationSettings): Promise<{lufsError: number, tpError: number}> {
  return new Promise((resolve, reject) => {
    let actualLUFS: number | null = null;
    let actualTP: number | null = null;
    
    const lra = settings?.customLRA || 11;
    let verifyFilter = `loudnorm=I=${targetLUFS}:TP=${targetTP}:LRA=${lra}:linear=true:print_format=summary`;
    
    if (settings?.useDualMono) {
      verifyFilter += ':dual_mono=true';
    }
    
    ffmpeg(filePath)
      .audioFilters(verifyFilter)
      .format('null')
      .output('-')
      .on('stderr', (stderrLine) => {
        if (stderrLine.includes('Input Integrated:')) {
          const match = stderrLine.match(/Input Integrated:\s*([+-]?\d*\.?\d+)\s*LUFS/);
          if (match) {
            actualLUFS = parseFloat(match[1]);
          }
        }
        if (stderrLine.includes('Input True Peak:')) {
          const match = stderrLine.match(/Input True Peak:\s*([+-]?\d*\.?\d+)\s*dBTP/);
          if (match) {
            actualTP = parseFloat(match[1]);
          }
        }
      })
      .on('end', () => {
        const lufsError = actualLUFS !== null ? Math.abs(actualLUFS - targetLUFS) : Number.MAX_VALUE;
        const tpError = actualTP !== null ? Math.abs(actualTP - targetTP) : Number.MAX_VALUE;
        resolve({ lufsError, tpError });
      })
      .on('error', (err) => {
        reject(err);
      })
      .run();
  });
}

// Helper function to clean up temporary files
async function cleanupTempFiles(originalInput: string, finalOutput: string, lastPass: number, intermediateFormat: string): Promise<void> {
  try {
    const tempDir = path.dirname(finalOutput);
    const fileName = path.basename(finalOutput, path.extname(finalOutput));
    const finalOutputFileName = path.basename(finalOutput);
    
    console.log(`Cleaning up temporary files for ${fileName}, last pass was ${lastPass}, format: ${intermediateFormat}`);
    console.log(`Final output file to PRESERVE: ${finalOutputFileName}`);
    
    // Remove specific temporary files from each pass
    for (let i = 1; i <= lastPass; i++) {
      const tempFile = path.join(tempDir, `${fileName}_temp_pass${i}.${intermediateFormat}`);
      if (fs.existsSync(tempFile)) {
        fs.unlinkSync(tempFile);
        console.log(`✅ Cleaned up temporary file: ${path.basename(tempFile)}`);
      }
    }
    
    // Also check for any other temp files that might have been created
    // BUT BE VERY CAREFUL not to delete the final output
    try {
      const files = fs.readdirSync(tempDir);
      
      // STRICT pattern that ONLY matches files with "_temp_pass" followed by digits
      const tempPattern = new RegExp(`^${fileName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}_temp_pass\\d+\\.(mp3|wav|flac|aac|m4a|ogg)$`, 'i');
      
      for (const file of files) {
        // CRITICAL SAFETY CHECK: Never delete the final output file
        if (file === finalOutputFileName) {
          console.log(`🔒 PROTECTED: Skipping final output file: ${file}`);
          continue;
        }
        
        // Only delete files that explicitly match the temp pattern
        if (tempPattern.test(file)) {
          const fullPath = path.join(tempDir, file);
          if (fs.existsSync(fullPath)) {
            console.log(`🧹 Cleaning up orphaned temp file: ${file}`);
            fs.unlinkSync(fullPath);
            console.log(`✅ Successfully deleted: ${file}`);
          }
        }
      }
    } catch (dirError) {
      console.warn('Could not read directory for orphaned file cleanup:', dirError);
    }
    
  } catch (error) {
    console.warn('Error cleaning up temporary files:', error);
  }
}

// Audio normalization function
async function normalizeAudio(
  inputPath: string, 
  outputPath: string, 
  targetLUFS: number,
  truePeakLimit: number,
  settings: NormalizationSettings,
  event: Electron.IpcMainInvokeEvent
): Promise<void> {
  return new Promise((resolve, reject) => {
    // Send initial progress
    mainWindow.webContents.send('progress-update', {
      filePath: inputPath,
      percent: 0
    });

    // Handle format preservation mode (force triple-pass with original format)
    if (settings.preserveOriginalFormat) {
      console.log('=== FORMAT PRESERVATION MODE ===');
      console.log('Forcing 3-pass processing with original format preservation');
      
      // Create a modified settings object for triple-pass processing
      const triplePassSettings = {
        ...settings,
        twoPassNormalization: true,
        maxPasses: 3,
        accuracyThreshold: 0.05, // Higher accuracy for format preservation
        useHighQualityMode: false // Use original format for intermediates
      };
      
      performIterativeNormalization(inputPath, outputPath, targetLUFS, truePeakLimit, triplePassSettings, event)
        .then(resolve)
        .catch(reject);
    } else if (settings.twoPassNormalization) {
      // Two-pass loudnorm for better accuracy
      if (settings.maxPasses && settings.maxPasses > 2) {
        // Use iterative multi-pass for maximum accuracy
        performIterativeNormalization(inputPath, outputPath, targetLUFS, truePeakLimit, settings, event)
          .then(resolve)
          .catch(reject);
      } else {
        // Standard two-pass
        performTwoPassNormalization(inputPath, outputPath, targetLUFS, truePeakLimit, settings, event)
          .then(resolve)
          .catch(reject);
      }
    } else {
      // Single-pass loudnorm (faster but less accurate)
      performSinglePassNormalization(inputPath, outputPath, targetLUFS, truePeakLimit, settings, event)
        .then(resolve)
        .catch(reject);
    }
  });
}

// Two-pass loudnorm implementation
async function performTwoPassNormalization(
  inputPath: string,
  outputPath: string,
  targetLUFS: number,
  truePeakLimit: number,
  settings: NormalizationSettings,
  event: Electron.IpcMainInvokeEvent
): Promise<void> {
  return new Promise((resolve, reject) => {
    console.log(`=== TWO-PASS NORMALIZATION ===`);
    console.log(`Input: ${inputPath}`);
    console.log(`Output: ${outputPath}`);
    console.log(`Target: ${targetLUFS} LUFS, ${truePeakLimit} dBTP`);
    
    let stderrBuffer = ''; // Collect all stderr for better parsing
    
    // First pass: analyze the audio with linear=true for better accuracy
    console.log('=== FIRST PASS: ANALYSIS ===');
    const lra = settings.customLRA || 11; // Use custom LRA or default to 11
    let firstPassFilter = `loudnorm=I=${targetLUFS}:TP=${truePeakLimit}:LRA=${lra}:linear=true:print_format=summary`;
    
    // Add dual_mono if enabled
    if (settings.useDualMono) {
      firstPassFilter += ':dual_mono=true';
    }
    
    ffmpeg(inputPath)
      .audioFilters(firstPassFilter)
      .format('null')
      .output('-')
      .on('start', (commandLine) => {
        console.log('First pass command:', commandLine);
      })
      .on('progress', (progress) => {
        const percent = Math.round((progress.percent || 0) * 0.5); // First pass is 50%
        mainWindow.webContents.send('progress-update', {
          filePath: inputPath,
          percent: percent
        });
      })
      .on('stderr', (stderrLine) => {
        // Collect all stderr for comprehensive parsing
        stderrBuffer += stderrLine + '\n';
        console.log('Analysis:', stderrLine);
      })
      .on('end', () => {
        console.log('=== FIRST PASS COMPLETE ===');
        
        // Use the robust parsing function
        const analysisResults = parseLoudnormAnalysis(stderrBuffer);
        console.log('Analysis results:', analysisResults);
        
        // Validate that all required parameters were extracted
        const requiredParams = ['measured_I', 'measured_TP', 'measured_LRA', 'measured_thresh', 'offset'];
        const missingParams = requiredParams.filter(param => analysisResults[param as keyof typeof analysisResults] === null);
        
        if (missingParams.length > 0) {
          console.error(`Missing analysis parameters: ${missingParams.join(', ')}`);
          console.log('Parsing failed for the following stderr output:');
          console.log(stderrBuffer);
          console.log('Falling back to single-pass normalization...');
          
          // Fallback to single-pass if analysis failed
          performSinglePassNormalization(inputPath, outputPath, targetLUFS, truePeakLimit, settings, event)
            .then(resolve)
            .catch(reject);
          return;
        }
        
        // Build second pass filter with measured values and linear=true
        let secondPassFilter = `loudnorm=I=${targetLUFS}:TP=${truePeakLimit}:LRA=${lra}:linear=true:measured_I=${analysisResults.measured_I}:measured_TP=${analysisResults.measured_TP}:measured_LRA=${analysisResults.measured_LRA}:measured_thresh=${analysisResults.measured_thresh}:offset=${analysisResults.offset}`;
        
        // Add dual_mono if enabled
        if (settings.useDualMono) {
          secondPassFilter += ':dual_mono=true';
        }
        
        console.log('=== SECOND PASS: PROCESSING ===');
        console.log('Second pass filter:', secondPassFilter);
        
        ffmpeg(inputPath)
          .audioFilters(secondPassFilter)
          .output(outputPath)
          .on('start', (commandLine) => {
            console.log('Second pass command:', commandLine);
          })
          .on('progress', (progress) => {
            const percent = 50 + Math.round((progress.percent || 0) * 0.5); // Second pass is 50-100%
            mainWindow.webContents.send('progress-update', {
              filePath: inputPath,
              percent: percent
            });
          })
          .on('stderr', (stderrLine) => {
            console.log('Second pass:', stderrLine);
          })
          .on('end', async () => {
            console.log('=== TWO-PASS PROCESSING COMPLETE ===');
            console.log('File saved to:', outputPath);
            
            try {
              // Verify the processed file
              console.log('=== VERIFICATION ===');
              await verifyProcessedAudio(outputPath, targetLUFS, truePeakLimit, settings);
              
              mainWindow.webContents.send('progress-update', {
                filePath: inputPath,
                percent: 100
              });
              resolve();
            } catch (verifyError) {
              console.error('Verification failed:', verifyError);
              mainWindow.webContents.send('progress-update', {
                filePath: inputPath,
                percent: 100
              });
              resolve();
            }
          })
          .on('error', (err) => {
            console.error(`Error in second pass:`, err);
            reject(err);
          })
          .run();
      })
      .on('error', (err) => {
        console.error(`Error in first pass:`, err);
        reject(err);
      })
      .run();
  });
}

// Single-pass loudnorm implementation
async function performSinglePassNormalization(
  inputPath: string,
  outputPath: string,
  targetLUFS: number,
  truePeakLimit: number,
  settings: NormalizationSettings,
  event: Electron.IpcMainInvokeEvent
): Promise<void> {
  return new Promise((resolve, reject) => {
    const filterString = buildLoudnormFilter(targetLUFS, truePeakLimit, settings);
    console.log('=== SINGLE-PASS NORMALIZATION ===');
    console.log('Input:', inputPath);
    console.log('Output:', outputPath);
    console.log('Filter:', filterString);

    ffmpeg(inputPath)
      .audioFilters(filterString)
      .output(outputPath)
      .on('start', (commandLine) => {
        console.log('FFmpeg command:', commandLine);
      })
      .on('progress', (progress) => {
        console.log(`Progress: ${progress.percent}%`);
        mainWindow.webContents.send('progress-update', {
          filePath: inputPath,
          percent: Math.round(progress.percent || 0)
        });
      })
      .on('stderr', (stderrLine) => {
        // Log important FFmpeg output
        console.log('FFmpeg stderr:', stderrLine);
      })
      .on('end', async () => {
        console.log('=== PROCESSING COMPLETE ===');
        console.log('File saved to:', outputPath);
        
        try {
          // Verify the processed file
          console.log('=== VERIFICATION ===');
          await verifyProcessedAudio(outputPath, targetLUFS, truePeakLimit, settings);
          
          mainWindow.webContents.send('progress-update', {
            filePath: inputPath,
            percent: 100
          });
          resolve();
        } catch (verifyError) {
          console.error('Verification failed:', verifyError);
          // Still resolve since the file was processed
          mainWindow.webContents.send('progress-update', {
            filePath: inputPath,
            percent: 100
          });
          resolve();
        }
      })
      .on('error', (err) => {
        console.error(`=== ERROR ===`);
        console.error(`Error normalizing ${inputPath}:`, err);
        reject(err);
      })
      .run();
  });
}

// Helper function to parse loudnorm analysis output more robustly
function parseLoudnormAnalysis(stderrOutput: string): {
  measured_I: number | null;
  measured_TP: number | null;
  measured_LRA: number | null;
  measured_thresh: number | null;
  offset: number | null;
} {
  const result = {
    measured_I: null as number | null,
    measured_TP: null as number | null,
    measured_LRA: null as number | null,
    measured_thresh: null as number | null,
    offset: null as number | null
  };

  // More robust parsing with multiple regex patterns for different output formats
  const patterns = {
    measured_I: [
      /measured_I=([+-]?\d*\.?\d+)/,
      /Input Integrated:\s*([+-]?\d*\.?\d+)\s*LUFS/,
      /Integrated Loudness:\s*([+-]?\d*\.?\d+)/
    ],
    measured_TP: [
      /measured_TP=([+-]?\d*\.?\d+)/,
      /Input True Peak:\s*([+-]?\d*\.?\d+)\s*dBTP/,
      /True Peak:\s*([+-]?\d*\.?\d+)/
    ],
    measured_LRA: [
      /measured_LRA=([+-]?\d*\.?\d+)/,
      /Input LRA:\s*([+-]?\d*\.?\d+)\s*LU/,
      /Loudness Range:\s*([+-]?\d*\.?\d+)/
    ],
    measured_thresh: [
      /measured_thresh=([+-]?\d*\.?\d+)/,
      /Input Threshold:\s*([+-]?\d*\.?\d+)\s*LUFS/,
      /Threshold:\s*([+-]?\d*\.?\d+)/
    ],
    offset: [
      /offset=([+-]?\d*\.?\d+)/,
      /Target Offset:\s*([+-]?\d*\.?\d+)\s*LU/
    ]
  };

  // Try each pattern for each parameter
  for (const [key, regexArray] of Object.entries(patterns)) {
    for (const regex of regexArray) {
      const match = stderrOutput.match(regex);
      if (match && match[1]) {
        const value = parseFloat(match[1]);
        if (!isNaN(value)) {
          result[key as keyof typeof result] = value;
          break; // Found a valid match, move to next parameter
        }
      }
    }
  }

  return result;
}

// Build the appropriate loudnorm filter string
function buildLoudnormFilter(targetLUFS: number, peakLimit: number, settings: NormalizationSettings): string {
  // Use loudnorm with linear=true for better accuracy in both LUFS and true peak processing
  const lra = settings.customLRA || 11; // Default to 11 LU if not specified
  let filterString = `loudnorm=I=${targetLUFS}:TP=${peakLimit}:LRA=${lra}:linear=true`;
  
  // Add dual_mono processing if enabled (provides better accuracy for stereo content)
  if (settings.useDualMono) {
    filterString += ':dual_mono=true';
    console.log('Using dual-mono processing for enhanced accuracy');
  }
  
  console.log(`Building loudnorm filter: ${filterString}`);
  console.log(`Target: ${targetLUFS} LUFS, ${peakLimit} dBTP, LRA=${lra} LU`);
  return filterString;
}

// Verify the processed audio meets our targets
async function verifyProcessedAudio(filePath: string, targetLUFS: number, targetTP: number, settings?: NormalizationSettings): Promise<void> {
  return new Promise((resolve, reject) => {
    console.log(`Verifying processed audio: ${filePath}`);
    console.log(`Expected: ${targetLUFS} LUFS, ${targetTP} dBTP`);
    
    let actualLUFS: number | null = null;
    let actualTP: number | null = null;
    
    // Use same settings as the actual processing for accurate verification
    const lra = settings?.customLRA || 11;
    let verifyFilter = `loudnorm=I=${targetLUFS}:TP=${targetTP}:LRA=${lra}:linear=true:print_format=summary`;
    
    if (settings?.useDualMono) {
      verifyFilter += ':dual_mono=true';
    }
    
    ffmpeg(filePath)
      .audioFilters(verifyFilter)
      .format('null')
      .output('-')
      .on('start', (commandLine) => {
        console.log('Verification command:', commandLine);
      })
      .on('stderr', (stderrLine) => {
        // Parse the verification results with better accuracy reporting
        if (stderrLine.includes('Input Integrated:')) {
          console.log('RESULT - Current file loudness:', stderrLine.trim());
          // Extract actual LUFS value
          const match = stderrLine.match(/Input Integrated:\s*([+-]?\d*\.?\d+)\s*LUFS/);
          if (match) {
            actualLUFS = parseFloat(match[1]);
          }
        }
        if (stderrLine.includes('Input True Peak:')) {
          console.log('RESULT - Current file true peak:', stderrLine.trim());
          // Extract actual true peak value
          const match = stderrLine.match(/Input True Peak:\s*([+-]?\d*\.?\d+)\s*dBTP/);
          if (match) {
            actualTP = parseFloat(match[1]);
          }
        }
        if (stderrLine.includes('Output Integrated:')) {
          console.log('CALCULATION - Would achieve loudness:', stderrLine.trim());
        }
        if (stderrLine.includes('Output True Peak:')) {
          console.log('CALCULATION - Would achieve true peak:', stderrLine.trim());
        }
      })
      .on('end', () => {
        console.log('=== VERIFICATION COMPLETE ===');
        
        // Report accuracy
        if (actualLUFS !== null) {
          const lufsError = Math.abs(actualLUFS - targetLUFS);
          console.log(`LUFS Accuracy: Target=${targetLUFS}, Actual=${actualLUFS.toFixed(1)}, Error=${lufsError.toFixed(1)} dB`);
          if (lufsError > 0.5) {
            console.warn(`⚠️  LUFS target missed by ${lufsError.toFixed(1)} dB - consider adjusting settings`);
          } else {
            console.log(`✅ LUFS target achieved within acceptable tolerance`);
          }
        }
        
        if (actualTP !== null) {
          const tpError = Math.abs(actualTP - targetTP);
          console.log(`True Peak Accuracy: Target=${targetTP}, Actual=${actualTP.toFixed(1)}, Error=${tpError.toFixed(1)} dB`);
          if (tpError > 0.5) {
            console.warn(`⚠️  True Peak target missed by ${tpError.toFixed(1)} dB - consider adjusting settings`);
          } else {
            console.log(`✅ True Peak target achieved within acceptable tolerance`);
          }
        }
        
        resolve();
      })
      .on('error', (err) => {
        console.error('Verification error:', err);
        reject(err);
      })
      .run();
  });
}

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
